;;; -*- Gerbil -*-
;;; Qt functional tests — dispatch-chain tests for the Qt backend.
;;; Mirrors the most critical TUI functional tests for the Qt code path.
;;;
;;; Run: QT_QPA_PLATFORM=offscreen .gerbil/bin/qt-functional-test
;;;
;;; Key principle: test through cmd-indent-or-complete / execute-command!,
;;; NOT by calling qt-try-org-template-expand directly.

(import :std/sugar
        (only-in :gerbil-qt/qt
                 with-qt-app
                 qt-widget-create
                 qt-widget-destroy!
                 qt-scintilla-create)
        :gerbil-scintilla/constants
        (only-in :gemacs/qt/sci-shim
                 sci-send
                 sci-send/string
                 qt-plain-text-edit-text
                 qt-plain-text-edit-set-text!
                 qt-plain-text-edit-cursor-position
                 qt-plain-text-edit-set-cursor-position!
                 qt-plain-text-edit-insert-text!
                 qt-scintilla-destroy!)
        (only-in :gemacs/core
                 new-app-state
                 execute-command!
                 find-command
                 make-buffer
                 app-state-last-command
                 app-state-prefix-arg)
        (only-in :gemacs/qt/window
                 make-qt-edit-window
                 make-qt-frame)
        (only-in :gemacs/qt/commands
                 qt-register-all-commands!))

(export main)

;;;============================================================================
;;; Test infrastructure
;;;============================================================================

(def *passes* 0)
(def *failures* 0)

(def (pass! label)
  (set! *passes* (+ *passes* 1))
  (displayln "  PASS: " label))

(def (fail! label actual expected)
  (set! *failures* (+ *failures* 1))
  (displayln "  FAIL: " label)
  (displayln "    got:      " actual)
  (displayln "    expected: " expected))

;; Create a minimal headless Qt test app.
;; Must be called inside with-qt-app.
;; Uses the widget's existing document pointer to avoid SCI_CREATEDOCUMENT
;; which can segfault in headless tests.
(def (make-qt-test-app name)
  (let* ((w   (qt-widget-create))
         (ed  (qt-scintilla-create parent: w))
         (doc (sci-send ed SCI_GETDOCPOINTER))
         (buf (make-buffer name #f doc #f #f #f #f))
         (win (make-qt-edit-window ed #f buf #f #f #f))
         (fr  (make-qt-frame #f (list win) 0 #f))
         (app (new-app-state fr)))
    (values ed w app)))

(def (destroy-qt-test-app! ed w)
  (qt-scintilla-destroy! ed)
  (qt-widget-destroy! w))

(def (set-qt-text! ed text pos)
  (qt-plain-text-edit-set-text! ed text)
  (qt-plain-text-edit-set-cursor-position! ed pos))

;;;============================================================================
;;; Test groups
;;;============================================================================

(def (run-group-1-org-tab-dispatch)
  (displayln "=== Group 1: Org-Mode TAB Dispatch ===")

  ;; Registration checks (no app needed)
  (displayln "Test: indent-or-complete is registered")
  (if (find-command 'indent-or-complete)
    (pass! "indent-or-complete registered")
    (fail! "indent-or-complete" #f "procedure"))

  (displayln "Test: org-template-expand is registered")
  (if (find-command 'org-template-expand)
    (pass! "org-template-expand registered")
    (fail! "org-template-expand" #f "procedure"))

  (displayln "Test: <s TAB expands to #+BEGIN_SRC")
  (let-values (((ed w app) (make-qt-test-app "test.org")))
    (set-qt-text! ed "<s" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "#+BEGIN_SRC")
        (pass! "<s → #+BEGIN_SRC")
        (fail! "<s expansion" text "contains #+BEGIN_SRC")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: <e TAB expands to #+BEGIN_EXAMPLE")
  (let-values (((ed w app) (make-qt-test-app "test.org")))
    (set-qt-text! ed "<e" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "#+BEGIN_EXAMPLE")
        (pass! "<e → #+BEGIN_EXAMPLE")
        (fail! "<e expansion" text "contains #+BEGIN_EXAMPLE")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: <q TAB expands to #+BEGIN_QUOTE")
  (let-values (((ed w app) (make-qt-test-app "test.org")))
    (set-qt-text! ed "<q" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "#+BEGIN_QUOTE")
        (pass! "<q → #+BEGIN_QUOTE")
        (fail! "<q expansion" text "contains #+BEGIN_QUOTE")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: <v TAB expands to #+BEGIN_VERSE")
  (let-values (((ed w app) (make-qt-test-app "test.org")))
    (set-qt-text! ed "<v" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "#+BEGIN_VERSE")
        (pass! "<v → #+BEGIN_VERSE")
        (fail! "<v expansion" text "contains #+BEGIN_VERSE")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: <c TAB expands to #+BEGIN_CENTER")
  (let-values (((ed w app) (make-qt-test-app "test.org")))
    (set-qt-text! ed "<c" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "#+BEGIN_CENTER")
        (pass! "<c → #+BEGIN_CENTER")
        (fail! "<c expansion" text "contains #+BEGIN_CENTER")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: <C TAB expands to #+BEGIN_COMMENT")
  (let-values (((ed w app) (make-qt-test-app "test.org")))
    (set-qt-text! ed "<C" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "#+BEGIN_COMMENT")
        (pass! "<C → #+BEGIN_COMMENT")
        (fail! "<C expansion" text "contains #+BEGIN_COMMENT")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: <l TAB expands to #+BEGIN_EXPORT latex")
  (let-values (((ed w app) (make-qt-test-app "test.org")))
    (set-qt-text! ed "<l" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "EXPORT latex")
        (pass! "<l → EXPORT latex")
        (fail! "<l expansion" text "contains EXPORT latex")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: <h TAB expands to #+BEGIN_EXPORT html")
  (let-values (((ed w app) (make-qt-test-app "test.org")))
    (set-qt-text! ed "<h" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "EXPORT html")
        (pass! "<h → EXPORT html")
        (fail! "<h expansion" text "contains EXPORT html")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: <a TAB expands to #+BEGIN_EXPORT ascii")
  (let-values (((ed w app) (make-qt-test-app "test.org")))
    (set-qt-text! ed "<a" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "EXPORT ascii")
        (pass! "<a → EXPORT ascii")
        (fail! "<a expansion" text "contains EXPORT ascii")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: <s in .org has both BEGIN and END blocks")
  (let-values (((ed w app) (make-qt-test-app "notes.org")))
    (set-qt-text! ed "<s" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (and (string-contains text "#+BEGIN_SRC")
               (string-contains text "#+END_SRC"))
        (pass! "<s expansion: BEGIN + END present")
        (fail! "<s completeness" text "#+BEGIN_SRC...#+END_SRC")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: non-org buffer (.ss) TAB does not expand <s")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (set-qt-text! ed "<s" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (not (string-contains text "#+BEGIN_SRC"))
        (pass! "non-org: <s not expanded")
        (fail! "non-org <s" text "no #+BEGIN_SRC")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: non-org buffer (.py) TAB does not expand <e")
  (let-values (((ed w app) (make-qt-test-app "script.py")))
    (set-qt-text! ed "<e" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (not (string-contains text "#+BEGIN_EXAMPLE"))
        (pass! ".py: <e not expanded")
        (fail! ".py <e" text "no #+BEGIN_EXAMPLE")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: org plain text TAB inserts 2 spaces")
  (let-values (((ed w app) (make-qt-test-app "notes.org")))
    (set-qt-text! ed "hello" 5)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "hello  ")
        (pass! "plain text org TAB → 2 spaces")
        (fail! "plain text indent" text "hello  ")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: unknown template <z in org → no expansion")
  (let-values (((ed w app) (make-qt-test-app "notes.org")))
    (set-qt-text! ed "<z" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (not (string-contains text "#+BEGIN_"))
        (pass! "<z not expanded")
        (fail! "<z should not expand" text "no #+BEGIN_")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: org heading TAB → org-cycle (no crash)")
  (let-values (((ed w app) (make-qt-test-app "notes.org")))
    (set-qt-text! ed "* Heading\n  Content" 0)
    (execute-command! app 'indent-or-complete)
    ;; Just verifying no exception thrown
    (pass! "heading TAB: no crash")
    (destroy-qt-test-app! ed w)))

(def (run-group-2-navigation)
  (displayln "=== Group 2: Navigation ===")

  (displayln "Test: forward-char moves cursor right")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'forward-char)
    (let ((pos (qt-plain-text-edit-cursor-position ed)))
      (if (= pos 1)
        (pass! "forward-char: 0 → 1")
        (fail! "forward-char" pos 1)))
    (destroy-qt-test-app! ed w))

  (displayln "Test: backward-char moves cursor left")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello")
    (qt-plain-text-edit-set-cursor-position! ed 3)
    (execute-command! app 'backward-char)
    (let ((pos (qt-plain-text-edit-cursor-position ed)))
      (if (= pos 2)
        (pass! "backward-char: 3 → 2")
        (fail! "backward-char" pos 2)))
    (destroy-qt-test-app! ed w))

  (displayln "Test: beginning-of-line goes to column 0")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello world")
    (qt-plain-text-edit-set-cursor-position! ed 7)
    (execute-command! app 'beginning-of-line)
    (let ((pos (qt-plain-text-edit-cursor-position ed)))
      (if (= pos 0)
        (pass! "beginning-of-line: 7 → 0")
        (fail! "beginning-of-line" pos 0)))
    (destroy-qt-test-app! ed w))

  (displayln "Test: end-of-line goes to end")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'end-of-line)
    (let ((pos (qt-plain-text-edit-cursor-position ed)))
      (if (= pos 5)
        (pass! "end-of-line: 0 → 5")
        (fail! "end-of-line" pos 5)))
    (destroy-qt-test-app! ed w))

  (displayln "Test: beginning-of-buffer goes to pos 0")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello world")
    (qt-plain-text-edit-set-cursor-position! ed 11)
    (execute-command! app 'beginning-of-buffer)
    (let ((pos (qt-plain-text-edit-cursor-position ed)))
      (if (= pos 0)
        (pass! "beginning-of-buffer")
        (fail! "beginning-of-buffer" pos 0)))
    (destroy-qt-test-app! ed w))

  (displayln "Test: end-of-buffer goes to last position")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'end-of-buffer)
    (let ((pos (qt-plain-text-edit-cursor-position ed)))
      (if (= pos 5)
        (pass! "end-of-buffer: 0 → 5")
        (fail! "end-of-buffer" pos 5)))
    (destroy-qt-test-app! ed w))

  (displayln "Test: forward-char at buffer end is no-op")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hi")
    (qt-plain-text-edit-set-cursor-position! ed 2)
    (execute-command! app 'forward-char)
    (let ((pos (qt-plain-text-edit-cursor-position ed)))
      (if (= pos 2)
        (pass! "forward-char at EOB: no-op")
        (fail! "forward-char at EOB" pos 2)))
    (destroy-qt-test-app! ed w))

  (displayln "Test: multiple forward-char calls accumulate")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "abcde")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'forward-char)
    (execute-command! app 'forward-char)
    (execute-command! app 'forward-char)
    (let ((pos (qt-plain-text-edit-cursor-position ed)))
      (if (= pos 3)
        (pass! "3x forward-char: 0 → 3")
        (fail! "3x forward-char" pos 3)))
    (destroy-qt-test-app! ed w)))

(def (run-group-3-basic-editing)
  (displayln "=== Group 3: Basic Editing ===")

  (displayln "Test: delete-char removes character at cursor")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'delete-char)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string=? text "ello")
        (pass! "delete-char removes 'h'")
        (fail! "delete-char" text "ello")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: backward-delete-char removes char before cursor")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello")
    (qt-plain-text-edit-set-cursor-position! ed 5)
    (execute-command! app 'backward-delete-char)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string=? text "hell")
        (pass! "backward-delete-char removes 'o'")
        (fail! "backward-delete-char" text "hell")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: newline inserts a newline at cursor")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello")
    (qt-plain-text-edit-set-cursor-position! ed 3)
    (execute-command! app 'newline)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "\n")
        (pass! "newline: inserts \\n")
        (fail! "newline insertion" text "contains \\n")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: kill-line removes text to end of line")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello world")
    (qt-plain-text-edit-set-cursor-position! ed 5)
    (execute-command! app 'kill-line)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string=? text "hello")
        (pass! "kill-line: removes from cursor to EOL")
        (fail! "kill-line" text "hello")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: undo reverses last edit")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'delete-char)
    (execute-command! app 'undo)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string=? text "hello")
        (pass! "undo restores after delete-char")
        (fail! "undo" text "hello")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: set-mark does not crash")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello world")
    (qt-plain-text-edit-set-cursor-position! ed 3)
    (execute-command! app 'set-mark)
    (pass! "set-mark: no crash")
    (destroy-qt-test-app! ed w)))

(def (run-group-4-org-commands)
  (displayln "=== Group 4: Org Commands via execute-command! ===")

  ;; Qt uses org-todo-cycle (not org-todo)
  (displayln "Test: org-todo-cycle cycles TODO state on heading")
  (let-values (((ed w app) (make-qt-test-app "tasks.org")))
    (qt-plain-text-edit-set-text! ed "* Task headline")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'org-todo-cycle)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "TODO")
        (pass! "org-todo-cycle: adds TODO keyword")
        (fail! "org-todo-cycle" text "contains TODO")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: org-demote then org-promote a heading")
  (let-values (((ed w app) (make-qt-test-app "notes.org")))
    (qt-plain-text-edit-set-text! ed "** Sub heading")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'org-demote)
    (let ((after-demote (qt-plain-text-edit-text ed)))
      (if (string-prefix? "***" after-demote)
        (pass! "org-demote: ** → ***")
        (fail! "org-demote" after-demote "starts with ***")))
    (execute-command! app 'org-promote)
    (let ((after-promote (qt-plain-text-edit-text ed)))
      (if (string-prefix? "** " after-promote)
        (pass! "org-promote: *** → **")
        (fail! "org-promote" after-promote "starts with ** ")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: org-promote at level 1 is a no-op")
  (let-values (((ed w app) (make-qt-test-app "notes.org")))
    (qt-plain-text-edit-set-text! ed "* Top level")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'org-promote)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-prefix? "* " text)
        (pass! "org-promote level-1: no-op")
        (fail! "org-promote level-1" text "starts with * ")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: org-toggle-checkbox toggles [ ] to [X]")
  (let-values (((ed w app) (make-qt-test-app "notes.org")))
    (qt-plain-text-edit-set-text! ed "- [ ] Item to check")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'org-toggle-checkbox)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "[X]")
        (pass! "org-toggle-checkbox: [ ] → [X]")
        (fail! "org-toggle-checkbox" text "contains [X]")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: org-toggle-checkbox toggles [X] back to [ ]")
  (let-values (((ed w app) (make-qt-test-app "notes.org")))
    (qt-plain-text-edit-set-text! ed "- [X] Already checked")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'org-toggle-checkbox)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "[ ]")
        (pass! "org-toggle-checkbox: [X] → [ ]")
        (fail! "org-toggle-checkbox" text "contains [ ]")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: org-insert-heading adds a new heading")
  (let-values (((ed w app) (make-qt-test-app "notes.org")))
    (qt-plain-text-edit-set-text! ed "* First\n")
    (qt-plain-text-edit-set-cursor-position! ed 7)
    (execute-command! app 'org-insert-heading)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (and (> (string-length text) 8)
               (string-contains text "*"))
        (pass! "org-insert-heading: new heading added")
        (fail! "org-insert-heading" text "longer with *")))
    (destroy-qt-test-app! ed w))

  ;; org-priority is not registered in the Qt command set; TUI covers it
  (displayln "Test: org-promote registered (Qt org command check)")
  (if (find-command 'org-promote)
    (pass! "org-promote: registered")
    (fail! "org-promote registration" #f "procedure")))

(def (run-group-5-text-transforms)
  (displayln "=== Group 5: Text Transforms ===")

  (displayln "Test: upcase-word uppercases word at point")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello world")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'upcase-word)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-prefix? "HELLO" text)
        (pass! "upcase-word: hello → HELLO")
        (fail! "upcase-word" text "HELLO world")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: downcase-word lowercases word at point")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "HELLO world")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'downcase-word)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-prefix? "hello" text)
        (pass! "downcase-word: HELLO → hello")
        (fail! "downcase-word" text "hello world")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: capitalize-word capitalizes first letter")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello world")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'capitalize-word)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-prefix? "Hello" text)
        (pass! "capitalize-word: hello → Hello")
        (fail! "capitalize-word" text "Hello world")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: join-line merges current line with next")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello\nworld")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'join-line)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (and (string-contains text "hello")
               (string-contains text "world")
               (not (string-contains text "\nhello")))
        (pass! "join-line: merges lines")
        (fail! "join-line" text "single line with hello and world")))
    (destroy-qt-test-app! ed w)))

(def (run-group-6-dispatch-chain)
  (displayln "=== Group 6: Dispatch Chain Integrity ===")

  (displayln "Test: execute-command! updates last-command")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'forward-char)
    (let ((lc (app-state-last-command app)))
      (if (eq? lc 'forward-char)
        (pass! "last-command = forward-char")
        (fail! "last-command" lc 'forward-char)))
    (destroy-qt-test-app! ed w))

  (displayln "Test: execute-command! resets prefix-arg after command")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "hello")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'universal-argument)
    (execute-command! app 'forward-char)
    (let ((after (app-state-prefix-arg app)))
      (if (eq? after #f)
        (pass! "prefix-arg reset to #f after command")
        (fail! "prefix-arg reset" after #f)))
    (destroy-qt-test-app! ed w))

  (displayln "Test: .org TAB → org path (template expanded)")
  (let-values (((ed w app) (make-qt-test-app "notes.org")))
    (set-qt-text! ed "<s" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string-contains text "#+BEGIN_SRC")
        (pass! ".org file: TAB takes org path")
        (fail! ".org TAB" text "contains #+BEGIN_SRC")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: .py TAB → plain indent (not org expansion)")
  (let-values (((ed w app) (make-qt-test-app "script.py")))
    (set-qt-text! ed "<s" 2)
    (execute-command! app 'indent-or-complete)
    (let ((text (qt-plain-text-edit-text ed)))
      (if (not (string-contains text "#+BEGIN_SRC"))
        (pass! ".py file: TAB does not expand <s")
        (fail! ".py TAB" text "no #+BEGIN_SRC")))
    (destroy-qt-test-app! ed w))

  (displayln "Test: multiple execute-command! calls accumulate cursor")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "abcde")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (execute-command! app 'forward-char)
    (execute-command! app 'forward-char)
    (execute-command! app 'forward-char)
    (let ((pos (qt-plain-text-edit-cursor-position ed)))
      (if (= pos 3)
        (pass! "3x forward-char via execute-command!")
        (fail! "multiple commands" pos 3)))
    (destroy-qt-test-app! ed w))

  (displayln "Test: insert-text via Qt API (basic sanity)")
  (let-values (((ed w app) (make-qt-test-app "test.ss")))
    (qt-plain-text-edit-set-text! ed "")
    (qt-plain-text-edit-set-cursor-position! ed 0)
    (qt-plain-text-edit-insert-text! ed "test")
    (let ((text (qt-plain-text-edit-text ed)))
      (if (string=? text "test")
        (pass! "insert-text: empty → test")
        (fail! "insert-text" text "test")))
    (destroy-qt-test-app! ed w)))

;;;============================================================================
;;; Main
;;;============================================================================

(def (main . args)
  (with-qt-app _app
    ;; Register all Qt commands once
    (qt-register-all-commands!)

    (run-group-1-org-tab-dispatch)
    (run-group-2-navigation)
    (run-group-3-basic-editing)
    (run-group-4-org-commands)
    (run-group-5-text-transforms)
    (run-group-6-dispatch-chain)

    (displayln "---")
    (displayln "Results: " *passes* " passed, " *failures* " failed")
    (if (= *failures* 0)
      (begin (displayln "All Qt functional tests passed!") (exit 0))
      (begin (displayln *failures* " failure(s)") (exit *failures*)))))
